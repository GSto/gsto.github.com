<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: rails | Glenn Stovall]]></title>
  <link href="http://glennstovall.com/blog/categories/rails/atom.xml" rel="self"/>
  <link href="http://glennstovall.com/"/>
  <updated>2014-12-28T15:53:32-05:00</updated>
  <id>http://glennstovall.com/</id>
  <author>
    <name><![CDATA[Glenn Stovall]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[How to Test Controller Concerns in Rails 4]]></title>
    <link href="http://glennstovall.com/blog/2014/05/06/how-to-test-controller-concerns-in-rails-4/"/>
    <updated>2014-05-06T15:06:00-04:00</updated>
    <id>http://glennstovall.com/blog/2014/05/06/how-to-test-controller-concerns-in-rails-4</id>
    <content type="html"><![CDATA[<p>{% img left /images/articles/ruby_on_rails.jpg 260 %}</p>

<p><a href="http://api.rubyonrails.org/classes/ActiveSupport/Concern.html">Concerns</a> are a new feature that was added in Rails 4. They allow to clean up code in your models and controllers. They also allow you to share functionality between models or controllers. However, they can be a bit tricky to test in isolation. In this article I want to show how you can test your controller concerns in isolation.</p>

<!-- more -->


<h2>The Over Simplified Scenario</h2>

<p>We have a project with several different types of objects that can be sold. Each item is unique and is marked as 'out of stock' once it is purchased. However, we have several different controllers and different types of purchases that need this functionality. In order to reduce code duplication, we are going to put these in a concern.</p>

<p>{% codeblock lang:ruby /app/controllers/concerns/transaction_processing.rb %}
module TransactionProcessing
  extend ActiveSupport::Concern</p>

<p>  included do</p>

<pre><code>helper_method :process_sale
</code></pre>

<p>  end</p>

<p>  def process_sale(item)</p>

<pre><code>item.is_in_stock = false
item.save!
</code></pre>

<p>  end
end
{% endcodeblock %}</p>

<p>If we want to test this concern, we need a controller to include it in. However, it would not be accurately unit testing to do this as there could be code in that controller that could affect the output of our test. Inside of our test, we can create a fake controller with no methods or logic of it's own, and then write tests for that. If you are using <a href="http://rspec.info/">RSpec</a>, you can call methods directly using the <code>subject</code> object. Here is my example test using RSpec and <a href="https://github.com/thoughtbot/factory_girl">FactoryGirl</a></p>

<p>{% codeblock lang:ruby /spec/controllers/concerns/transaction_processing_spec.rb %}
require 'spec_helper'</p>

<p>class FakesController &lt; ApplicationController
  include TransactionProcessing
end</p>

<p>describe FakesController do</p>

<p>  it "should mark an item out of stock" do</p>

<pre><code>item = create(:item, is_in_stock: true)
subject.process_sale(item)
expect(item.is_in_stock).to be false
</code></pre>

<p>  end
end
{% endcodeblock %}</p>

<p>And there you go! Easy, isolated tests for your controller concerns.</p>
]]></content>
  </entry>
  
</feed>
